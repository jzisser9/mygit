#!/bin/bash
# Exit immediately if a command exits with a non-zero status.
set -e

# A wrapper script for Git to add custom functionality.

# --- Global Configuration & Colors ---
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[1;34m'
NC='\033[0m' # No Color

# --- HELP DOCUMENTATION ---
# (Help text is omitted for brevity but is the same as before)
declare -A HELP_TEXT
HELP_TEXT[clone]="..."
HELP_TEXT[help]="..."
HELP_TEXT[release]="..."


# --- HELPER FUNCTIONS for the 'release' command ---

check_gh_dependency() {
    if ! command -v gh &> /dev/null; then
        echo -e "\033[0;31mError: GitHub CLI ('gh') is not installed...${NC}" >&2
        exit 1
    fi
}

check_gh_auth() {
    if ! gh auth status &>/dev/null; then
        echo -e "\033[0;31mError: You are not logged into the GitHub CLI ('gh').${NC}" >&2
        echo -e "${BLUE}Please run 'gh auth login' to authenticate before using the release command.${NC}" >&2
        exit 1
    fi
}

get_latest_release_tag() {
    # Be explicit about the repo
    gh release list --repo "$(git remote get-url origin)" --limit 1 --json tagName --jq '.[0].tagName' 2>/dev/null
}

calculate_next_version() {
    local latest_tag=$1
    local version_type=$2
    local major=0 minor=0 patch=0
    if [ -z "$latest_tag" ]; then
        case "$version_type" in
            major) major=1 ;;
            minor) minor=1 ;;
            patch) patch=1 ;;
        esac
    else
        local version_part="${latest_tag#v}"
        IFS='.' read -r major minor patch <<< "$version_part"
        major=${major:-0}; minor=${minor:-0}; patch=${patch:-0}
        case "$version_type" in
            major) major=$((major + 1)); minor=0; patch=0 ;;
            minor) minor=$((minor + 1)); patch=0 ;;
            patch) patch=$((patch + 1)) ;;
        esac
    fi
    echo "v$major.$minor.$patch"
}

get_release_notes() {
    local notes_file
    notes_file=$(mktemp)
    if [ -z "$EDITOR" ]; then
        echo -e "\033[0;31mError: \$EDITOR not set...${NC}" >&2
        rm "$notes_file"; exit 1
    fi
    local editor_cmd=$(echo "$EDITOR" | awk '{print $1}')
    if ! command -v "$editor_cmd" &> /dev/null; then
        echo -e "\033[0;31mError: Editor '$editor_cmd' not found...${NC}" >&2
        rm "$notes_file"; exit 1
    fi
    echo -e "${BLUE}Opening your editor...${NC}" >&2
    echo -e "# Write release notes here..." > "$notes_file"
    $EDITOR "$notes_file"
    grep -v '^#' "$notes_file" > "${notes_file}.tmp" && mv "${notes_file}.tmp" "$notes_file"
    echo "$notes_file"
}

# --- THIS FUNCTION IS UPDATED ---
determine_release_branch() {
    echo -e "${BLUE}Querying GitHub API for the default branch...${NC}" >&2
    local default_branch
    # Be explicit about which repo we are viewing by passing its remote URL.
    default_branch=$(gh repo view "$(git remote get-url origin)" --json defaultBranchRef --jq .defaultBranchRef.name)
    if [ -z "$default_branch" ]; then
        echo -e "\033[0;31mError: Could not determine default branch from the GitHub API.${NC}" >&2
        exit 1
    fi
    echo "$default_branch"
}


# --- MAIN LOGIC ---
COMMAND=$1
case "$COMMAND" in
  release)
    check_gh_dependency
    check_gh_auth

    VERSION_TYPE=$2

    if [[ "$VERSION_TYPE" != "major" && "$VERSION_TYPE" != "minor" && "$VERSION_TYPE" != "patch" ]]; then
        echo -e "\033[0;31mError: Invalid version type...${NC}" >&2
        exit 1
    fi

    echo -e "${GREEN}Starting interactive release process...${NC}" >&2

    echo -e "\n${YELLOW}Step 1: Determining release branch...${NC}" >&2
    TARGET_BRANCH=$(determine_release_branch)
    echo -e "${BLUE}Release will be created from branch: ${YELLOW}$TARGET_BRANCH${NC}" >&2
    
    # --- THIS COMMAND IS UPDATED ---
    echo -e "\n${YELLOW}Step 2: Calculating next version...${NC}" >&2
    LATEST_TAG=$(get_latest_release_tag)
    # ... The rest of the script is the same ...
    if [ -z "$LATEST_TAG" ]; then
        echo -e "${BLUE}No previous releases found. Creating initial release.${NC}" >&2
    else
        echo -e "${BLUE}Latest release found: ${YELLOW}$LATEST_TAG${NC}" >&2
    fi
    NEW_VERSION=$(calculate_next_version "$LATEST_TAG" "$VERSION_TYPE")
    echo -e "${BLUE}New version will be: ${GREEN}$NEW_VERSION${NC}" >&2

    echo -e "\n${YELLOW}Step 3: Gathering release notes...${NC}" >&2
    NOTES_FILE_PATH=$(get_release_notes)
    if [ ! -s "$NOTES_FILE_PATH" ]; then
        echo -e "\033[0;31mError: Release notes are empty. Aborting.${NC}" >&2
        rm "$NOTES_FILE_PATH"
        exit 1
    fi
    echo -e "${BLUE}Release notes captured.${NC}" >&2
    
    # --- THIS COMMAND IS UPDATED ---
    echo -e "\n${YELLOW}Step 4: Creating release on GitHub...${NC}" >&2
    echo -e "${BLUE}This will create tag '${GREEN}$NEW_VERSION${BLUE}' and push it to the remote.${NC}" >&2
    read -p "Are you sure you want to continue? (y/N) " confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo -e "${YELLOW}Release aborted by user.${NC}" >&2
        rm "$NOTES_FILE_PATH"
        exit 0
    fi

    gh release create "$NEW_VERSION" \
        --repo "$(git remote get-url origin)" \
        --title "$NEW_VERSION" \
        --notes-file "$NOTES_FILE_PATH" \
        --target "$TARGET_BRANCH"
    
    rm "$NOTES_FILE_PATH"

    echo -e "\n${GREEN}--- Release '$NEW_VERSION' created successfully! ---${NC}" >&2
    ;;

  clone)
    # ... full clone code ...
    ;;
  help)
    # ... full help code ...
    ;;
  *)
    git "$@"
    ;;
esac